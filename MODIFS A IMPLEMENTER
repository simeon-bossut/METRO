modif crea stations : for()-> +2

station 0 et max deviennent stockage
station 0 et max -> lignes se rejoignent
station 0 et max -> diff logo station
station 0 et max -> pas de quai

création station 0 et max :

/////////////////////////////////////////////////////////////////////////////////////////

						//personnes dans les rames






						V = fait	/	 X = à faire




/*
à mettre dans le main :

V -> srand(std::time(nullptr));

*/


V -> int delai_1_personne = 0.2; //temps par personne
X -> int delai_attente = delai_1_personne*(nb_descente + nb_montee);

X -> int capa_max_rame = 200; //capacité max de la rame
X -> int capa_max_quai = 500; //capacité max de la station


X -> int personnes_dans_rame = 0; //nb de personnes actuellement dans la rame (max : 200)
X -> int personnes_sur_quai = 0; //nb de personnes actuellement sur le quai (max : 500)


X -> int nb_descente = 0; //nb de personnes qui descendent de la rame (entre 0 et nb actuel de personnes dans la rame)
X -> int nb_montee = 0; //nb de personnes qui montent dans la rame (min(capa_max_rame - personnes_dans_rame, personnes_sur_quai))





[ ajout semi-régulier de personnes sur le quai, à implémenter une fois que je sais faire et que j'ai compris où mettre ce bordel:


/!\ utiliser un thread ? /!\


X -> int diff_quai = 0; //capa_max_quai - personnes_sur_quai

X -> toutes les "rand(1 à 10 secondes)" : 

X -> 	if (personnes_sur_quai < capa_max_quai) //tant que le quai n'est pas plein, on continue de le remplir
X -> 	{
X -> 		diff_quai = capa_max_quai - personnes_sur_quai; //on regarde le monbre de places libres restantes sur le quai
X -> 
X -> 		if (diff_quai < 10) si il reste moins de 10 places libres sur le quai, on fait attention à pas dépasser la capa max
X -> 		{
X -> 			personnes_sur_quai += rand() % (10-diff_quai);
X -> 		}
X -> 		else
X -> 		{
X -> 			personnes_sur_quai += rand() % 10;
X -> 		}
X -> 	}

]





								//personnes_sur_quai += rand() % (capa_max_quai - personnes_sur_quai);


X -> nb_descente = rand() % personnes_dans_rame;
X -> personnes_dans_rame -= nb_descente;

X -> nb_montee = min(capa_max_rame - personnes_dans_rame, personnes_sur_quai);
X -> personnes_dans_rame += nb_montee;
X -> personnes_sur_quai -= nb_montee;



/////////////////////////////////////////////////////////////////////////////////////////

							//distance de sécurité entre les rames (pseudo-code)




while (distance_rame[rame_devant] > sécurité && [distance_station[i] > code déjà fait])
{
	[gestion vitesse basique]
}

if (distance_rame <= sécurité)
{
	//enclenchement arrêt urgence (affichage)
		cout ? affichage stml ?
	//diminution importante de la vitesse voire arrêt (attention à pas ralentir trop fort non plus)
	while (vitesse > threshold)
	{
		acceleration = -qqchose;
		vitesse += acceleration; //varier le freinage en fonction de la distance à l'autre rame ?
	}
	//ralentissement des rames derrière ? (sera déjà implémenté je suis con)

}

if (distance_rame <= 0)
{
	//accident (affichage)
	//arrêt des autres rames au fur et à mesure (implémenté juste au dessus)
	//évacuation des rames dans les stations les plus proches ?
	nb_accident(var_globale) += 1;
	accident_rame(var_locale) = 1;
	vitesse(de la rame accidentée) = 0;
	accélération(de la rame accidentée) = 0;
}

while (nb_accident != 0) //tant que l'accident n'est pas résolu
{
	if (rame dans station)
	{
		nb_descente = personnes_dans_rame;
		personnes_dans_rame = 0;
		nb_montée = 0;
		vitesse = 0;
		accélération = 0;
	}
	else
	{
		if (distance_station_suivante < distance_rame_suivante)
		{
			//avance jusque la station suivante à vitesse réduite
		}
		else
		{
			//tkt poto
		}
	}

}


/////////////////////////////////////////////////////////////////////////////////////////




																	//tmp_main_Alex

#include "METRO.hpp"

using namespace std;

int main()
{


	string file_name="biblio_nom_stat.txt";
	//*cout << "Quel est le nom du fichier voulu ? (sans espace svp) \n\n";
	//cin >> file_name; */
	//fstream my_file(file_name,ios::app);
	//string stat_name;
	//if (1)
	//{
	//	do {
	//		sf::sleep(sf::milliseconds(2000));
	//		cout << " entrez le nom de la station à ajouter au fichier si non tapez N \n\n";
	//		cin >> stat_name;
	//		while (cin.peek() != '\n') {
	//			string add;
	//			cin >> add;
	//			stat_name += " ";
	//			stat_name += add;
	//		}

	//		modif_string(stat_name, ' ', '/');
	//		if (stat_name != "N")
	//		{
	//			my_file << stat_name << " ";
	//		}

	//	} while (stat_name != "N");
	//	my_file.close();
	//}

	//Create the main window
	sf::RenderWindow window(sf::VideoMode(2000, 1200), "SFML window");//,sf::Style::Fullscreen

	string ASSETS = "../../../../METRO/assets/";

	//// Load a sprite to display

	sf::Texture texture_ram;
	if (!texture_ram.loadFromFile(ASSETS + "rame2.png"))
		return EXIT_FAILURE;

	sf::Texture texture_stat;
	if (!texture_stat.loadFromFile(ASSETS + "station.png"))
		return EXIT_FAILURE;
	sf::Vector2u stat_size = texture_stat.getSize();

					//cout << "dimensions de la station" << stat_size.x << "," << stat_size.y << endl << endl;


	//System M(file_name,10,texture_ram,texture_stat);
	//M.print();

	int nb_stat = 10;
	Sprite rame(texture_ram);
	Vector2f rame_size = rame.getGlobalBounds().getSize();
	rame.setOrigin(rame_size.x / 2, rame_size.y / 2);
	rame.setScale(0.25, 0.25);


	vector<Sprite> SPRITE_STATIONS;
	vector<CircleShape> QUAIS_HAUT;
	vector<CircleShape> QUAIS_BAS;
	vector<RectangleShape> LIGNE_TRAJET;
	vector<RectangleShape> LIGNE_TRAJET_ALLER;
	vector<RectangleShape> LIGNE_TRAJET_RETOUR;
	vector<Vector2f> STATION; //position des stations

	float decalage = 25.0;
	float factor_size_stat = 0.1;

	for (int i = 0;i < nb_stat;++i)				//ATTENTION : ajout des stations 0 et max (stations de transition) -> nb_stat+2
	{
		SPRITE_STATIONS.push_back(Sprite(texture_stat));

		STATION.push_back(Vector2f((float)(300 + 130 * i),(float)( 550 + 50 * (i - 4) * cos(2 * i))));

		 //STATIONS ET QUAIS

		SPRITE_STATIONS.back().setOrigin(stat_size.x / 2, stat_size.y / 2); //place l'origine de l'image en son centre
		SPRITE_STATIONS.back().setPosition(STATION[i].x, STATION[i].y); //position

		QUAIS_HAUT.push_back(sf::CircleShape(10.f));
		QUAIS_HAUT.back().setOrigin(10,10);

		QUAIS_BAS.push_back(sf::CircleShape(10.f));
		QUAIS_BAS.back().setOrigin(10, 10);

		if (i > 0)
		{
			float norm_vect = sqrt((STATION[i].x - STATION[i - 1].x) * (STATION[i].x - STATION[i - 1].x) + (STATION[i].y - STATION[i - 1].y) * (STATION[i].y - STATION[i - 1].y));

			if (i == 1 || i == nb_stat-1)
			{
				SPRITE_STATIONS.back().setScale(0, 0); //taille

				QUAIS_HAUT.back().setPosition(STATION[i]);
				QUAIS_BAS.back().setPosition(STATION[i]);

				if (i == 1)
				{
					LIGNE_TRAJET_ALLER.push_back(RectangleShape(Vector2f(norm_vect, 2.f)));
					LIGNE_TRAJET_RETOUR.push_back(RectangleShape(Vector2f(norm_vect, 2.f)));

					LIGNE_TRAJET_ALLER.back().setPosition(STATION[i]);

					float angle_debut = atan(abs(QUAIS_HAUT[i].getPosition().x - QUAIS_HAUT[i - 1].getPosition().x) / abs(QUAIS_HAUT[i].getPosition().y - QUAIS_HAUT[i - 1].getPosition().y)) * ((STATION[i].y - STATION[i - 1].y) > 0 ? 1 : -1);

					
					LIGNE_TRAJET_ALLER.back().setRotation((float)(angle_debut * 180 / 3.14));

					LIGNE_TRAJET_RETOUR.back().setPosition(STATION[i - 1]);
					LIGNE_TRAJET_RETOUR.back().setRotation((float)(angle_debut * 180 / 3.14));
				}
				/*else {
					LIGNE_TRAJET_ALLER.back().setPosition(STATION[i]);

					float angle_debut = atan(abs(QUAIS_HAUT[i].getPosition().x - QUAIS_HAUT[i - 1].getPosition().x) / abs(QUAIS_HAUT[i].getPosition().y - QUAIS_HAUT[i - 1].getPosition().y)) * ((STATION[i].y - STATION[i - 1].y) > 0 ? 1 : -1);
					
					LIGNE_TRAJET_ALLER.back().setRotation((float)(angle_debut * 180 / 3.14));

					LIGNE_TRAJET_RETOUR.back().setPosition(STATION[i - 1]);
					LIGNE_TRAJET_RETOUR.back().setRotation((float)(angle_debut * 180 / 3.14));
				}*/
			}
			else
			{
				SPRITE_STATIONS.back().setScale(factor_size_stat, factor_size_stat); //taille

				QUAIS_HAUT.back().setPosition(STATION[i] - Vector2f(0.0, decalage));
				QUAIS_BAS.back().setPosition(STATION[i] + Vector2f(0.0, decalage));

				// cout << norm_vect << endl;

				float angle = acos((STATION[i].x - STATION[i - 1].x) / norm_vect) * ((STATION[i].y - STATION[i - 1].y) > 0 ? 1 : -1); // à modif en atan


				//création des deux lignes séparées


				LIGNE_TRAJET_ALLER.push_back(RectangleShape(Vector2f(norm_vect, 2.f)));
				LIGNE_TRAJET_RETOUR.push_back(RectangleShape(Vector2f(norm_vect, 2.f)));

				LIGNE_TRAJET_ALLER.back().setPosition(STATION[i - 1] - Vector2f(0.0, 25.0));
				LIGNE_TRAJET_ALLER.back().setRotation((float)(angle * 180 / 3.14));

				LIGNE_TRAJET_RETOUR.back().setPosition(STATION[i - 1] + Vector2f(0.0, 25.0));
				LIGNE_TRAJET_RETOUR.back().setRotation((float)(angle * 180 / 3.14));


				// cout << LIGNE_TRAJET[i-1].getSize().x << "," << LIGNE_TRAJET[i-1].getSize().y << endl;
			}
		}
	}

	Rame R1;
	R1.speed = 2;

	std::thread t1(&Rame::start_move, &R1, std::ref(STATION),decalage);
	t1.detach();


	while (window.isOpen()) //affichage
	{
		//Process events
		sf::Event event;
		//while (window.pollEvent(event))
		//{
		//	// on regarde le type de l'évènement...
		//	switch (event.type)
		//	{
		//		// fenêtre fermée
		//	case sf::Event::Closed:
		//		window.close();
		//		break;
		//		// on ne traite pas les autres types d'évènements
		//	default:
		//		break;
		//	}
		//}

		while (window.pollEvent(event)) // conditions de fermeture de la fenêtre
		{
			if ((event.type == Event::KeyPressed && event.key.code == sf::Keyboard::Escape) || event.type == Event::Closed) //si on appuie sur échap ou qu'on ferme la fenêtre
			{
				window.close();
			}
		}

		sf::sleep(sf::milliseconds(10));
		// Clear screen
		window.clear();

		// Draw the sprite
		for (int i = 0; i < SPRITE_STATIONS.size(); ++i)
		{


			if (i != SPRITE_STATIONS.size() - 1)
			{
				window.draw(LIGNE_TRAJET_ALLER[i]);
				window.draw(LIGNE_TRAJET_RETOUR[i]);
			}
			window.draw(SPRITE_STATIONS[i]);
			window.draw(QUAIS_HAUT[i]);
			window.draw(QUAIS_BAS[i]);
		}
		//rame.setPosition(Vector2f(R1.position.x-rame_size.x/2,R1.position.y - rame_size.y / 2));
		rame.setPosition(R1.position);//+Vector2f(0,decalage)
		rame.setRotation(R1.angle * 180 / 3.14);
		window.draw(rame);
		// Update the window
		window.display();

	}

	return EXIT_SUCCESS;
}













																		//tmp_main_Simeon

#include "METRO.hpp"

using namespace std;

int main()
{


	string file_name="biblio_nom_stat.txt";
	//*cout << "Quel est le nom du fichier voulu ? (sans espace svp) \n\n";
	//cin >> file_name; */
	//fstream my_file(file_name,ios::app);
	//string stat_name;
	//if (1)
	//{
	//	do {
	//		sf::sleep(sf::milliseconds(2000));
	//		cout << " entrez le nom de la station à ajouter au fichier si non tapez N \n\n";
	//		cin >> stat_name;
	//		while (cin.peek() != '\n') {
	//			string add;
	//			cin >> add;
	//			stat_name += " ";
	//			stat_name += add;
	//		}

	//		modif_string(stat_name, ' ', '/');
	//		if (stat_name != "N")
	//		{
	//			my_file << stat_name << " ";
	//		}

	//	} while (stat_name != "N");
	//	my_file.close();
	//}

	//Create the main window
	sf::RenderWindow window(sf::VideoMode(2000, 1200), "SFML window");//,sf::Style::Fullscreen

	string ASSETS = "../../../../METRO/assets/";

	//// Load a sprite to display

	sf::Texture texture_ram;
	if (!texture_ram.loadFromFile(ASSETS + "rame2.png"))
		return EXIT_FAILURE;

	sf::Texture texture_stat;
	if (!texture_stat.loadFromFile(ASSETS + "station.png"))
		return EXIT_FAILURE;
	sf::Vector2u stat_size = texture_stat.getSize();

					//cout << "dimensions de la station" << stat_size.x << "," << stat_size.y << endl << endl;


	//System M(file_name,10,texture_ram,texture_stat);
	//M.print();

	int nb_stat = 6;
	Sprite rame(texture_ram);
	Vector2f rame_size = rame.getGlobalBounds().getSize();
	rame.setOrigin(rame_size.x / 2, rame_size.y / 2);
	rame.setScale(0.25, 0.25);


	vector<Sprite> LIGNE_STAT;
	vector<CircleShape> QUAIS_HAUT;
	vector<CircleShape> QUAIS_BAS;
	vector<RectangleShape> LIGNE_TRAJET;
	vector<RectangleShape> LIGNE_TRAJET_ALLER;
	vector<RectangleShape> LIGNE_TRAJET_RETOUR;
	vector<Vector2f> STATION; //position des stations

	float decalage = 25.0;
	float factor_size_stat = 0.1;
	for (int i = 0;i < nb_stat;++i)
	{
		LIGNE_STAT.push_back(Sprite(texture_stat));
		STATION.push_back(Vector2f((float)(300 + 200 * i),(float)( 550 + 50 * (i - 4) * cos(4 * i))));

		// STATIONS

		LIGNE_STAT.back().setOrigin(stat_size.x / 2, stat_size.y / 2); //place l'origine de l'image en son centre
		LIGNE_STAT.back().setPosition(STATION[i].x, STATION[i].y); //position
		LIGNE_STAT.back().setScale(factor_size_stat, factor_size_stat); //taille

		//QUAIS

		QUAIS_HAUT.push_back(sf::CircleShape(10.f));
		QUAIS_HAUT.back().setOrigin(10,10);
		QUAIS_HAUT.back().setPosition(STATION[i] - Vector2f(0.0, decalage));

		QUAIS_BAS.push_back(sf::CircleShape(10.f));
		QUAIS_BAS.back().setOrigin(10, 10);
		QUAIS_BAS.back().setPosition(STATION[i] + Vector2f(0.0, decalage));




		if (i > 0)
		{
			float norm_vect = sqrt((STATION[i].x - STATION[i - 1].x) * (STATION[i].x - STATION[i - 1].x) + (STATION[i].y - STATION[i - 1].y) * (STATION[i].y - STATION[i - 1].y));

							// cout << norm_vect << endl;
		
			float angle = acos((STATION[i].x - STATION[i - 1].x) / norm_vect) * ((STATION[i].y - STATION[i - 1].y) > 0 ? 1 : -1);



			//création des deux lignes séparées

			LIGNE_TRAJET_ALLER.push_back(RectangleShape(Vector2f(norm_vect, 2.f)));
			LIGNE_TRAJET_ALLER.back().setPosition(STATION[i - 1] - Vector2f(0.0, 25.0));
			LIGNE_TRAJET_ALLER.back().setRotation((float)(angle * 180 / 3.14));

			LIGNE_TRAJET_RETOUR.push_back(RectangleShape(Vector2f(norm_vect, 2.f)));
			LIGNE_TRAJET_RETOUR.back().setPosition(STATION[i - 1]+Vector2f(0.0,25.0));
			LIGNE_TRAJET_RETOUR.back().setRotation((float)(angle * 180 / 3.14));

			
							// cout << LIGNE_TRAJET[i-1].getSize().x << "," << LIGNE_TRAJET[i-1].getSize().y << endl;
		}
	}

	Rame R1;
	R1.speed = 0;
	R1.acceleration = -15;

	std::thread t1(&Rame::start_move, &R1, std::ref(STATION),decalage);
	t1.detach();


	while (window.isOpen()) //affichage
	{
		//Process events
		sf::Event event;
		//while (window.pollEvent(event))
		//{
		//	// on regarde le type de l'évènement...
		//	switch (event.type)
		//	{
		//		// fenêtre fermée
		//	case sf::Event::Closed:
		//		window.close();
		//		break;
		//		// on ne traite pas les autres types d'évènements
		//	default:
		//		break;
		//	}
		//}

		while (window.pollEvent(event)) // conditions de fermeture de la fenêtre
		{
			if ((event.type == Event::KeyPressed && event.key.code == sf::Keyboard::Escape) || event.type == Event::Closed) //si on appuie sur échap ou qu'on ferme la fenêtre
			{
				window.close();
			}
		}

		sf::sleep(sf::milliseconds(10));
		// Clear screen
		window.clear();

		// Draw the sprite
		for (int i = 0;i < LIGNE_STAT.size();++i)
		{

			if (i != LIGNE_STAT.size() - 1)
			{
				window.draw(LIGNE_TRAJET_ALLER[i]);
				window.draw(LIGNE_TRAJET_RETOUR[i]);
			}
			window.draw(LIGNE_STAT[i]);
			window.draw(QUAIS_HAUT[i]);
			window.draw(QUAIS_BAS[i]);
		}
		//rame.setPosition(Vector2f(R1.position.x-rame_size.x/2,R1.position.y - rame_size.y / 2));
		rame.setPosition(R1.position);//+Vector2f(0,decalage)
		rame.setRotation(R1.angle * 180 / 3.14);
		window.draw(rame);
		// Update the window
		window.display();

	}

	return EXIT_SUCCESS;
}